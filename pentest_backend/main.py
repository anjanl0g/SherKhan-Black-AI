import subprocess
import os
import logging
from fastapi import FastAPI, UploadFile, File
from pydantic import BaseModel
# FIXED: Updated import from deprecated 'langchain_community' to 'langchain_ollama'
from langchain_ollama import OllamaLLM
from fastapi.middleware.cors import CORSMiddleware
# Blue Team / Network Analysis Library
from scapy.all import rdpcap, IP, TCP, UDP

# Logging Setup
logging.basicConfig(level=logging.INFO)

app = FastAPI()

# Allow Frontend Connection
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- üß† DUAL AI BRAINS ---
# FIXED: Replaced 'Ollama' class with 'OllamaLLM'
# Engine 1: Hacker Mode (Uncensored / Attack Strategies)
llm_hacker = OllamaLLM(model="dolphin-mistral")

# Engine 2: Coder Mode (Safe / Scripting / Debugging)
llm_coder = OllamaLLM(model="qwen2.5-coder")

# Data Model (Includes 'mode' for switching)
class QueryRequest(BaseModel):
    query: str
    mode: str = "hacker"  # Default to Hacker mode

# --- üõ†Ô∏è HELPER FUNCTIONS ---

def run_command(command, timeout=300):
    """Executes Linux shell commands safely with a timeout."""
    try:
        # Shell=True allows complex commands (pipes, redirects)
        process = subprocess.run(
            command, shell=True, capture_output=True, text=True, timeout=timeout
        )
        if process.returncode == 0:
            return process.stdout
        else:
            return f"Error Output: {process.stderr}"
    except subprocess.TimeoutExpired:
        return "Error: Command took too long to execute."
    except Exception as e:
        return f"System Error: {str(e)}"

def analyze_pcap_data(file_path):
    """Analyzes Wireshark/PCAP files using Scapy for Blue Teaming."""
    try:
        packets = rdpcap(file_path)
        summary = []
        summary.append(f"Total Packets Captured: {len(packets)}")
        
        # Quick Analysis of first 20 packets
        details = []
        ips = set()
        protocols = set()

        # Added safety check for empty pcap
        limit = min(len(packets), 20)
        for pkt in packets[:limit]:
            if IP in pkt:
                src = pkt[IP].src
                dst = pkt[IP].dst
                ips.add(src)
                ips.add(dst)
                
                proto = "OTHER"
                if TCP in pkt: proto = "TCP"
                elif UDP in pkt: proto = "UDP"
                protocols.add(proto)

                details.append(f"{src} -> {dst} [{proto}]")

        summary.append(f"Active IPs Found: {list(ips)}")
        summary.append(f"Protocols: {list(protocols)}")
        summary.append("Traffic Sample:\n" + "\n".join(details))
        
        return "\n".join(summary)
    except Exception as e:
        return f"Error reading PCAP file: {str(e)}"

# --- üåê API ENDPOINTS ---

@app.post("/chat")
async def chat_endpoint(request: QueryRequest):
    try:
        user_input = request.query.lower()
        
        # --- üî¥ RED TEAM TOOLS ---
        
        # 1. NMAP (Network Scanning)
        if "nmap" in user_input:
            # Extract target (basic logic)
            parts = user_input.split()
            target = parts[-1].replace("http://", "").replace("https://", "") if parts else "localhost"
            cmd = f"nmap -F {target}"
            return {"reply": f"üöÄ **Nmap Scan Started on {target}...**\n\n" + run_command(cmd)}

        # 2. NIKTO (Web Vulnerability)
        elif "nikto" in user_input:
            parts = user_input.split()
            target = parts[-1] if parts else "localhost"
            cmd = f"nikto -h {target} -Tuning 123b"
            return {"reply": f"üíÄ **Nikto Web Vuln Scan on {target}...**\n(This may take time)\n\n" + run_command(cmd)}

        # 3. GOBUSTER (Directory Busting)
        elif "gobuster" in user_input:
            parts = user_input.split()
            target = parts[-1] if parts else "localhost"
            if not target.startswith("http"): target = "http://" + target
            # Using standard Kali wordlist
            wordlist = "/usr/share/wordlists/dirb/common.txt" 
            cmd = f"gobuster dir -u {target} -w {wordlist} -t 20 --no-error"
            return {"reply": f"üïµÔ∏è‚Äç‚ôÇÔ∏è **Gobuster Directory Hunt on {target}...**\n\n" + run_command(cmd)}

        # 4. SEARCHSPLOIT (Exploit DB)
        elif "exploit" in user_input or "searchsploit" in user_input:
            parts = user_input.split()
            keyword = parts[-1] if parts else "linux"
            cmd = f"searchsploit {keyword}"
            return {"reply": f"üí£ **Searching ExploitDB for '{keyword}'...**\n\n" + run_command(cmd)}

        # --- ‚ö´ BLACK TEAM TOOLS ---

        # 5. HYDRA (Brute Force)
        elif "hydra" in user_input:
            parts = user_input.split()
            target = parts[-1] if parts else "localhost"
            # Basic SSH attack template
            cmd = f"hydra -l admin -P /usr/share/wordlists/rockyou.txt ssh://{target} -t 4 -f -V"
            return {"reply": f"üî• **Hydra Brute-Force Initiated on {target}...**\n(Targeting 'admin' user)\n\n" + run_command(cmd)}

        # 6. SHERLOCK (OSINT)
        elif "sherlock" in user_input:
            parts = user_input.split()
            username = parts[-1] if parts else "admin"
            cmd = f"sherlock {username} --timeout 5 --print-found"
            return {"reply": f"ü¶Ö **Sherlock OSINT Hunt for '{username}'...**\n\n" + run_command(cmd)}

        # 7. MACCHANGER (Anonymity)
        elif "macchanger" in user_input:
            cmd = "macchanger -r eth0"
            return {"reply": f"üëª **Spoofing MAC Address...**\n\n" + run_command(cmd)}
            
        # --- ü§ñ HYBRID AI LOGIC ---
        else:
            # Check which mode is active from frontend
            if request.mode == "coder":
                # Use Qwen (Safe/Smart)
                system_prompt = f"Act as a Senior Cyber-Security Developer. Write clean, bug-free code for: {request.query}"
                # FIXED: Added error handling for model execution
                response = llm_coder.invoke(system_prompt)
                prefix = "üíª **Qwen-Coder Output:**\n"
            else:
                # Use Dolphin (Uncensored/Hacker)
                system_prompt = f"Act as Sher Khan Black A.I (Uncensored Red Team Operator). Provide a direct, technical answer for: {request.query}"
                response = llm_hacker.invoke(system_prompt)
                prefix = "üòà **Dolphin-Mistral Output:**\n"
                
            return {"reply": prefix + str(response)}

    except Exception as e:
        logging.error(f"Error in chat_endpoint: {e}")
        return {"reply": f"‚ùå **System Error:** {str(e)}"}

@app.post("/upload")
async def upload_file(file: UploadFile = File(...)):
    try:
        # 1. Save the file
        upload_dir = "uploads"
        os.makedirs(upload_dir, exist_ok=True)
        file_path = os.path.join(upload_dir, file.filename)
        
        with open(file_path, "wb") as f:
            f.write(await file.read())
        
        # 2. Check File Type for Analysis
        
        # If PCAP (Wireshark) File -> Blue Team Logic
        if file.filename.endswith(".pcap") or file.filename.endswith(".cap") or file.filename.endswith(".pcapng"):
            summary = analyze_pcap_data(file_path)
            # Use Coder model for analytical thinking
            prompt = f"Act as a SOC Analyst. Analyze this network traffic summary for potential attacks or anomalies:\n\n{summary}"
            analysis = llm_coder.invoke(prompt)
            return {"reply": f"üõ°Ô∏è **PCAP Network Analysis: {file.filename}**\n\n{analysis}"}
        
        # If Log/Code/Text File -> General Analysis
        else:
            # Read text content (Limit to 3000 chars)
            with open(file_path, "r", errors="ignore") as f:
                content = f.read(3000)
                
            prompt = f"Analyze this log file or code snippet for security vulnerabilities, bugs, or IOCs:\n\n{content}"
            # Use Hacker model for finding exploits
            analysis = llm_hacker.invoke(prompt)
            return {"reply": f"üìÇ **File Analysis Report: {file.filename}**\n\n{analysis}"}
            
    except Exception as e:
        logging.error(f"Error in upload_file: {e}")
        return {"reply": f"‚ùå **Upload/Analysis Error:** {str(e)}"}
